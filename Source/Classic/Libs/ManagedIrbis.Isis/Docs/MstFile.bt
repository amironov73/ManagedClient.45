// Управляющая запись
struct Control
{
    DWORD   Mfn;        // Всегда 0
    DWORD   NextMfn;    // Следующий новый MFN
    DWORD   NextBlock;  // Следующий свободный блок
    WORD    NextOffset; // Следующее смещение в блоке
    WORD    MftType;    // Всегда 0
};

// Заголовок записи
typedef struct Leader
{
    DWORD   Mfn;     // MFN записи
    short   Length;  // Длина, м. б. отрицательной
    local short RealLength = Abs(Length);
    DWORD   BackRef; // Блок с предыдущей версией
    WORD    BackOfs; // Смещение в блоке пред. версии
    WORD    Base;    // Начало данных полей
    WORD    Nvf;     // Количество полей
    WORD    Status;  // Статус
} LEADER<read=readLeader>;

char[] readLeader ( LEADER &leader )
{
    string s;
    SPrintf ( s, "MFN=%d", leader.Mfn );
    return s;
}

// Элемент справочника
typedef struct Dict
{
    WORD    Tag;  // Метка
    WORD    Pos;  // Смещение от начала данных
    short   Len;  // Длина в байтах
} DICT<read=readDict>;

char[] readDict ( DICT &dict )
{
    string s;
    SPrintf 
        ( 
            s, 
            "%d %d %d", 
            dict.Tag, 
            dict.Pos, 
            dict.Len 
        );
    return s;
}

// Поле переменной длины
typedef struct Field ( int len )
{
    if (len <= 0)
    {
        Printf ("unexpected len=%d", len);
        return 0;
    }

    char    Value[len];
} FIELD<read=readField>;

char[] readField ( FIELD &field )
{
    string s;
    SPrintf (s, "%s", field.Value);
    return s;
}

// Запись
struct Record
{
    // Начало записи в файле
    local int64 begin<format=hex> = FTell ();
    
    // Заголовок
    LEADER leader<bgcolor=0xFFD0D0>;

    if ((leader.Nvf == 0)
        || (leader.RealLength == 0))
    {
        return 0;
    }

    // Справочник
    DICT dict[leader.Nvf]<bgcolor=0xD0FFD0>;

    // Конец записи
    local int64 end<format=hex,hidden=true> 
        = begin + leader.RealLength;

    // Поля переменной длины
    for ( i = 0; i < record.leader.Nvf; i++ )
    {
        FSeek 
            ( 
                record.begin 
                + record.leader.Base 
                + record.dict[i].Pos 
            );
        FIELD field ( record.dict[i].Len );
    }

    FSeek (end);
};

Control control;

FSeek (0x40);

local int64 padding<hidden=true>, 
            savePos<hidden=true>;
local int i<hidden=true>;

while (!FEof())
{
    Record record;

    if ((record.leader.RealLength == 0)
        || (record.leader.RealLength > 32000))
        break;
    

    padding = 512 - (record.end % 512);
    if (padding <= 12)
    {
        FSeek ( record.end + padding );
    }
}