\chapter{Описание классов}

\section{Класс ManagedIrbis}

ManagedIrbis – «рабочая лошадка». Этот класс осуществляет связь с сервером, всю необходимую «перепаковку» данных и прочее и прочее. Собственно, это и есть управляемый клиент ИРБИС64.

Экземпляр клиента создаётся конструктором по умолчанию:
\begin{lstlisting}
var client = new ManagedIrbis ();
\end{lstlisting}

\subsection{Подключение к серверу}

Параметры подключения к серверу определяются следующими свойствами:

\begin{lstlisting}
public string Host { get; set; }
public int Port { get; set; }
public string Username { get; set; }
public string Password { get; set; }
public string Database { get; set; }
public IrbisWorkstation Workstation { get; set; }
\end{lstlisting}

\subsection{Работа с базой данных}

Имя текущей базы данных (каталога), с которой работает клиент, хранится в поле Database:
\begin{lstlisting}
public string Database { get; set; }
\end{lstlisting}
Кроме того, имеются два полезных метода:
\begin{lstlisting}
/// Временно устанавливает новое имя текущей базы данных.
/// Запоминает, к какой базе был подключен
/// клиент на момент смены.
/// Возвращает имя предыдущей текущей базы данных.
public string PushDatabase(string newDatabase);

/// Восстанавливает подключение к предыдущей базе данных,
/// сменённой методом PushDatabase().
/// Возвращает имя базы данных, к которой был подключен 
/// клиент на момент восстановления состояния.
public string PopDatabase()
\end{lstlisting}
Оба метода работают по принципу стека: предыдущие базы данных запоминаются в стеке и постепенно возвращаются по мере вызова метода PopDatabase(). Пример:
\begin{lstlisting}
// Мы работали с базой IBIS, 
// но решили временно подключиться к RDR
client.PushDatabase ("RDR"); // IBIS запоминается в стеке
IrbisRecord reader = client.SearchReadOneRecord ("I=1234");

// Теперь временно подключаемся к RQST
client.PushDatabase ("RQST"); // RDR также запоминается в стеке
IrbisRecord request = new IrbisRecord ();
...
client.WriteRecord (request, false, true); // Запись пойдёт в RQST

...
// Возвращаемся к базе RDR
client.PopDatabase ();
client.WriteRecord (reader, false, true); // Запись пойдёт в RDR

...
// Возвращаемся к исходной базе IBIS
client.PopDatabase ();
Рекомендую временные переключения между базами оформлять в блоке try-finally: 
client.PushDatabase ("CMPL");
try
{
   // Какие-то манипуляции с базой
}
finally
{
  // Гарантированно возвращаемся в правильный контекст
  // работы с базой данных
  client.PopDatabase();
}
\end{lstlisting}

\subsection{Последовательный поиск}

В простейшем случае этот поиск состоит из указания двух выражений: 1) обычное поисковое выражение, отбирающее записи по словарю, 2) булево выражение, которое будет применено к каждой найденной записи. 

Пример такого поиска: сначала мы отбираем все книги с фамилией автора "Пушкин", а затем проверяем, не содержит ли поле 200 буквосочетания "сказк": 
\begin{lstlisting}
// Выполняем последовательный поиск
int[] found = Client.SequentialSearch
    (
        "\"A=Пушкин$\"", // отбор по словарю
        "v200:'сказк'"   // булево выражение
    );

// Выводим найденные записи на консоль
foreach (int mfn in found)
{
    string description = Client.FormatRecord
        (
            "@brief",
            mfn
        );
    Console.WriteLine(description);
}
\end{lstlisting}
На экран будет выведено что-то вроде: 
\begin{verbatim}
Пушкин, Александр Сергеевич. Сказка о царе Салтане, о сыне его славном и могучем богатыре князе Гвидоне Салтановиче и о прекрасной царевне Лебеди / А.С. Пушкин ; Послесл. М. Сокольникова; Ил. А.М. Куркина (Палех), 1972. - 39 c. 

Пушкин, Александр Сергеевич. Сказки / А.С. Пушкин; Ил. А. Кокорина, 1976. - 72 с. 

Пушкин, Александр Сергеевич. Собрание сочинений : В 10 т. Т.3. : Поэмы. Сказки, 1982. - 671 с. 

Пушкин, Александр Сергеевич. Сказка о царе Салтане,о сыне его славном и могучем богатыре князе Гвидоне Салтановиче и о прекрасной царевне Лебеди / А.С. Пушкин, 1971. - 94 с. 

Пушкин, Александр Сергеевич. Сочинения : в 2 т. Т. 1 : Стихотворения, поэмы, сказки, 1982. - 365 с. 
\end{verbatim}

Есть вариант этого же метода, предоставляющий больший контроль: 
\begin{lstlisting}
Client.SequentialSearch
(
"\"A=Пушкин$\"",
100,   // запрашиваемое количество записей
1,     // номер первой записи (смещение)
10000, // минимальный MFN
20000, // максимальный MFN
"v200:'сказк'"        
);
\end{lstlisting}
Если вместо "\"A=Пушкин\$\"" передать null, то будет выполнен последовательный поиск по всей базе данных, что, скорее всего, создаст большую нагрузку на сервер. 

Подробнее см. документацию на протокол ИРБИС": http://sntnarciss.ru/irbis/spravka/wtcp007007020.htm.